:page-title: Creating and Sharing Resourced
:page-description: Extends JUnit Jupiter with a mechanism to create, share, and inject resources like temporary directories or a port.
:xp-demo-dir: ../src/demo/java
:demo: {xp-demo-dir}/org/junitpioneer/jupiter/resource/ResourcesExtensionDemo.java
:in-memory-directory: {xp-demo-dir}/org/junitpioneer/jupiter/resource/InMemoryDirectory.java

Some tests need "resources" which need to be cleaned up when finished, and sometimes, these resources might be needed to be accessed by many tests.
Furthermore, you may be running your JUnit Jupiter tests in parallel, which makes sharing these resources flaky.

For example, you might want to share a temporary directory.
This can be a problem if the directory isn't deleted after your tests, or your tests try to read and write files at the same time.

This extension separates parsing annotations, injecting new or shared resources, and registering them for getting cleaned up (which is needed for all kinds of resources) from actually creating and closing them (which is specific to each kind of resource).

[NOTE]
====
This article describes the general mechanisms shared by different resource extensions but not their specifics.
Check the individual documentations for that:

* link:docs/temp-directory[Temporary directory]
====

The first part of this article describes how to use a resource with this extension. The second part describes how to integrate your own kind of resource with this mechanism.
In both cases, the temporary directory extension will be used as an example, but what's described here applies to other resources as well.

== Using Resources

There are two different approaches to using a resource:

* Creating a new one for a given test.
* Sharing one between several tests.

=== Creating a New Resource

==== Creation

To create a new resource for a given test:

[source,java,indent=0]
----
include::{demo}[tag=create_new_resources_demo]
----

...where `TemporaryDirectory` is a built-in resource for creating link:docs/temp-directory[temporary directories].

This will create a brand-new resource for each test, and each resource which will be "closed" at the end of its associated test.

So in this case, a new temporary directory will be created `test1` and another one will be created for `test2`.
The temporary directory for `test1` will be deleted when the test is finished.
Likewise, the temporary directory for `test2` will also be deleted right after its test.

==== Creation with Arguments

Some resources accept string arguments to control their behaviour.

For example, `TemporaryDirectory` may accept a String argument to set the name of the temporary directory that is created:

[source,java,indent=0]
----
include::{demo}[tag=create_new_resource_with_arg_demo]
----

=== Sharing a Resource

To create a resource that is shared by multiple tests:

[source,java,indent=0]
----
include::{demo}[tag=create_shared_resource_demo]
----

...where `TemporaryDirectory` is a built-in resource for creating link:docs/temp-directory[temporary directories].

This will create a single resource instance that will be injected into all the tests.
It will be "closed" when all the tests are finished. (See <<scope_of_a_shared_resource>> for a caveat on this.)

So in this case, a single temporary directory will be shared across all tests, and it will only be deleted when all the tests have run.

=== Sharing Multiple Resources

The following code snippet shows an example of creating two shared resources.

In this case, tests `firstSharedResource1` and `firstSharedResource2` use the same temporary directory, and test `secondSharedResource` uses a different temporary directory.

[source,java,indent=0]
----
include::{demo}[tag=create_multiple_shared_resources_demo]
----

[#scope_of_a_shared_resource]
=== Scope of a Shared Resource

By default, a shared resource will be closed when the test file using it has finished.

This means that if a resource is shared across two or more test files, it will be closed and re-created for _each_ test file.

If this behaviour isn't what you want, you can change the "scope" of the resource to "global", which will keep the resource around until _all_ test files have finished:

[source,java,indent=0]
----
include::{demo}[tag=create_global_shared_resource_demo_first]
----

[source,java,indent=0]
----
include::{demo}[tag=create_global_shared_resource_demo_second]
----

[NOTE]
====

You are not limited to singletons! You can create as many global shared resources as you want.

====

=== Thread Safety

Resources may be _mutable_.

Temporary directories are a good example of this, as tests can create new subdirectories and files in them.

So, to prevent thread safety bugs, when a resource is shared, it will force any test using it to run sequentially, even if parallel execution has been enabled or that test has been annotated with JUnit Jupiter's `@Execution(CONCURRENT)`.

===

=== Creation with Arguments

[NOTE]
====

We do not support creating shared resources with arguments.

If you would like us to support this, please raise a https://github.com/junit-pioneer/junit-pioneer/issues/new[new issue].

====

== Integrating Resources

This extension allows you to integrate your own kind of resource with the mechanisms described above.

To do that, you need to implement `Resource<T>` and `ResourceFactory<T>`, where `T` is the type of resource you want to provide (e.g. `Path` for temporary directories).

Then you can reference the factory type in the `@New` and `@Shared` annotations.

This extension will take care of calling the various methods at the right time.

=== Set up the Factory

[source,java,indent=0]
----
public final class InMemoryDirectory implements ResourceFactory<Path> {

	private static final AtomicInteger DIRECTORY_NAME = new AtomicInteger();

	// The resource factory we want to create resources with.
	// In this case, an in-memory filesystem.
	private final FileSystem fileSystem;

	// NOTE: The constructor must be parameter-less.
	public InMemoryDirectory() {
		this.fileSystem = Jimfs.newFileSystem(Configuration.unix());
	}

	@Override
	public Resource<Path> create(List<String> arguments) throws Exception {
		// ...
	}

}
----

=== Close the Factory

[source,java,indent=0]
----
public final class InMemoryDirectory implements ResourceFactory<Path> {

	// ...

	private final FileSystem fileSystem;

	// ...

	// NOTE: Overriding close() is optional! By default, it will do nothing.
	@Override
	public void close() throws Exception {
		this.fileSystem.close();
	}

}
----

=== Create a Resource

[source,java,indent=0]
----
public final class InMemoryDirectory implements ResourceFactory<Path> {

	// ...

	private final FileSystem fileSystem;

	// ...

	@Override
	public Resource<Path> create(List<String> arguments) throws Exception {
		// Create a new resource from the factory.
		// In this case, return a new directory from
		// the in-memory filesystem.

		Path newInMemoryDirectory = this.fileSystem.getPath("/" + DIRECTORY_NAME.getAndIncrement());
		Files.createDirectory(newInMemoryDirectory);

		return new Resource<Path>() {

			@Override
			public Path get() throws Exception {
				return newInMemoryDirectory;
			}

			// ...

		};
	}

}
----

=== Close a Resource

[source,java,indent=0]
----
public final class InMemoryDirectory implements ResourceFactory<Path> {

	// ...

	private final FileSystem fileSystem;

	// ...

	@Override
	public Resource<Path> create(List<String> arguments) throws Exception {

		Path newInMemoryDirectory = // ...
		// ...

		return new Resource<Path>() {

			// ...

			// NOTE: Overriding close() is optional! By default, it will do nothing.
			@Override
			public void close() throws Exception {
				Files.walkFileTree(newInMemoryDirectory, new SimpleFileVisitor<Path>() {

					@Override
					public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
						Files.deleteIfExists(file);
						return FileVisitResult.CONTINUE;
					}

					@Override
					public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
						Files.deleteIfExists(dir);
						return FileVisitResult.CONTINUE;
					}

				});
			}

		};
	}

}
----

=== Working with Arguments from `@New`

[source,java,indent=0]
----
public final class InMemoryDirectory implements ResourceFactory<Path> {

	// ...

	@Override
	public Resource<Path> create(List<String> arguments) throws Exception {
		// The parameter 'arguments' contains all strings
		// passed to @New(..., arguments = { ... }).
		//
		// It's then up to you how these arguments should
		// be used.
		//
		// In this case, only the first argument is used,
		// and it's used as a prefix in the in-memory
		// directory's name.

		String directoryPrefix = (arguments.size() == 1) ? arguments.get(0) : "";
		Path newInMemoryDirectory = this.fileSystem.getPath("/" + directoryPrefix + DIRECTORY_NAME.getAndIncrement());
		Files.createDirectory(newInMemoryDirectory);

		return new Resource<Path>() {

			@Override
			public Path get() throws Exception {
				return newInMemoryDirectory;
			}

			// ...

		};

	}
}
----

=== Putting It All Together

[source,java,indent=0]
----
include::{in-memory-directory}[tag=in_memory_directory]
----
